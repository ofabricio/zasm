
val_to_hex_str
    pusha
    mov di HEX_OUT + 05
    mov cx 04
    > mov ax bx
    and al 0F
    cmp al 09
    jle >           ; jump to "add al 30" below.
    add al 07
    > add al 30
    mov [di] al
    dec di
    shr bx 04
    dec cx
    jnz <<          ; jump to "mov ax bx" above. A single '<' would jump to "add al 30".
    popa
    ret

HEX_OUT db '0x0000' 00

; ----

global_label
    mov eax ebx
.loc_label
    dec eax
    jnz .loc_label
    jz global_label.loc_label

; ----

    db 00
    dw 01 02 03 04
    db 'hello' 0A 00
    dd ?

    times 0200 - ($ - $$) db 00

; ----

    00
    arr 01 00 02 00 03 00

; Is the same as:

        db 00
    arr dw 01 02 03

; And:

    mov eax ebx
    90
    mov ecx ebx

; Is the same as:

    mov eax ebx
    nop
    mov ecx ebx

; ----

@org 7C00
@align 04
@include 'example.asm'

@struct Point {
    x db 00
    y db 00
}

@print {
}

@define VALUE 0123

@if VERSION == 0
    nop
@elseif VERSION == 1
    ; code...
@else
    ; code...
@end

@ifndef __PRINT__
@define __PRINT__
    ; code...
@end
@guard __PRINT__

@macro pushes a b {
    push a
    push b
}

    #pushes eax ebx
    call hello

; ----

    #example(eax, ebx, ecx, out r)
    mov eax r
    ret

@fn example (keep eax, ebx, stack v, out r) {
    mov eax ebx
    add eax v
    mov r eax
}

; ----

    sub  esp 04         ; "out" keyword reserves space for the returning value.
    push ecx            ; "stack" keyword uses the stack.
    call example
    add  esp 08
    mov  eax [esp-04]   ; [esp-04] is r from "out r"
    ret

example 
    push eax            ; "keep" keyword prevents trashing a register.
    mov  eax ebx
    add  eax [esp+04]   ; [esp+04] is v from "stack v"
    mov  [esp+08] eax   ; [esp+08] is r from "out r"
    pop  eax
    ret

; ----

@template 'GDT' code {
    Base        0
    Limit       0
    G           0
}
